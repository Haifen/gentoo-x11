From a290b879c76caa3d6496bc1e07bc8fbe7449edcd Mon Sep 17 00:00:00 2001
From: Keith Packard <keithp@keithp.com>
Date: Fri, 17 Oct 2008 00:07:09 -0700
Subject: [PATCH] Handle differently tiled front/back/depth/third in DRI window management

When moving or clearing the extra buffer contents associated with DRI
windows, the XAA code needs to see which buffer is being manipulated in the
Setup functions to program the tiling values correctly. Calling
I830SelectBuffer and not then calling I830Setup... would result in mis-tiled
rendering.

Signed-off-by: Keith Packard <keithp@keithp.com>
Signed-off-by: Eric Anholt <eric@anholt.net>
---
 src/i830.h       |    2 +-
 src/i830_accel.c |    9 +++-
 src/i830_dri.c   |  131 +++++++++++++++++++++++++++---------------------------
 3 files changed, 74 insertions(+), 68 deletions(-)

diff --git a/src/i830.h b/src/i830.h
index 823bfef..dc79d7c 100644
--- a/src/i830.h
+++ b/src/i830.h
@@ -755,7 +755,7 @@ extern Bool I830CursorInit(ScreenPtr pScreen);
 extern void IntelEmitInvarientState(ScrnInfoPtr pScrn);
 extern void I830EmitInvarientState(ScrnInfoPtr pScrn);
 extern void I915EmitInvarientState(ScrnInfoPtr pScrn);
-extern void I830SelectBuffer(ScrnInfoPtr pScrn, int buffer);
+extern Bool I830SelectBuffer(ScrnInfoPtr pScrn, int buffer);
 void i830_update_cursor_offsets(ScrnInfoPtr pScrn);
 
 /* CRTC-based cursor functions */
diff --git a/src/i830_accel.c b/src/i830_accel.c
index 52e22ba..e29982a 100644
--- a/src/i830_accel.c
+++ b/src/i830_accel.c
@@ -244,7 +244,7 @@ I830EmitFlush(ScrnInfoPtr pScrn)
    }
 }
 
-void
+Bool
 I830SelectBuffer(ScrnInfoPtr pScrn, int buffer)
 {
    I830Ptr pI830 = I830PTR(pScrn);
@@ -253,12 +253,18 @@ I830SelectBuffer(ScrnInfoPtr pScrn, int buffer)
 #ifdef XF86DRI
    case I830_SELECT_BACK:
       pI830->bufferOffset = pI830->back_buffer->offset;
+      if (pI830->back_buffer->tiling == TILE_YMAJOR)
+	 return FALSE;
       break;
    case I830_SELECT_THIRD:
       pI830->bufferOffset = pI830->third_buffer->offset;
+      if (pI830->third_buffer->tiling == TILE_YMAJOR)
+	 return FALSE;
       break;
    case I830_SELECT_DEPTH:
       pI830->bufferOffset = pI830->depth_buffer->offset;
+      if (pI830->depth_buffer->tiling == TILE_YMAJOR)
+	 return FALSE;
       break;
 #endif
    default:
@@ -270,6 +276,7 @@ I830SelectBuffer(ScrnInfoPtr pScrn, int buffer)
    if (I810_DEBUG & DEBUG_VERBOSE_ACCEL)
       ErrorF("I830SelectBuffer %d --> offset %x\n",
 	     buffer, pI830->bufferOffset);
+   return TRUE;
 }
 
 /* The following function sets up the supported acceleration. Call it
diff --git a/src/i830_dri.c b/src/i830_dri.c
index cc771d7..944558b 100644
--- a/src/i830_dri.c
+++ b/src/i830_dri.c
@@ -1199,47 +1199,42 @@ I830DRIInitBuffers(WindowPtr pWin, RegionPtr prgn, CARD32 index)
 {
    ScreenPtr pScreen = pWin->drawable.pScreen;
    ScrnInfoPtr pScrn = xf86Screens[pScreen->myNum];
-   BoxPtr pbox = REGION_RECTS(prgn);
-   int nbox = REGION_NUM_RECTS(prgn);
+   BoxPtr pbox;
+   int nbox;
+   int buffer, first_buffer, last_buffer;
 
+   return;
    if (I810_DEBUG & DEBUG_VERBOSE_DRI)
       ErrorF("I830DRIInitBuffers\n");
 
-   I830SetupForSolidFill(pScrn, 0, GXcopy, -1);
-   while (nbox--) {
-      I830SelectBuffer(pScrn, I830_SELECT_BACK);
-      I830SubsequentSolidFillRect(pScrn, pbox->x1, pbox->y1,
-				  pbox->x2 - pbox->x1, pbox->y2 - pbox->y1);
+   first_buffer = I830_SELECT_BACK;
+   last_buffer = I830_SELECT_DEPTH;
+   if (I830PTR(pScrn)->third_buffer)
+      last_buffer = I830_SELECT_THIRD;
 
-      if (I830PTR(pScrn)->third_buffer) {
-	 I830SelectBuffer(pScrn, I830_SELECT_THIRD);
+   for (buffer = first_buffer; buffer <= last_buffer; buffer++) {
+      pbox = REGION_RECTS(prgn);
+      nbox = REGION_NUM_RECTS(prgn);
+
+      if (!I830SelectBuffer(pScrn, buffer))
+	 continue;
+
+      if (buffer == I830_SELECT_DEPTH) {
+	 switch (pScrn->bitsPerPixel) {
+	 case 16:
+	    I830SetupForSolidFill(pScrn, 0xffff, GXcopy, -1);
+	    break;
+	 case 32:
+	    I830SetupForSolidFill(pScrn, 0xffffff, GXcopy, -1);
+	    break;
+	 }
+      } else
+	 I830SetupForSolidFill(pScrn, 0, GXcopy, -1);
+      while (nbox--) {
 	 I830SubsequentSolidFillRect(pScrn, pbox->x1, pbox->y1,
 				     pbox->x2 - pbox->x1, pbox->y2 - pbox->y1);
+	 pbox++;
       }
-
-      pbox++;
-   }
-
-   /* Clear the depth buffer - uses 0xffff rather than 0.
-    */
-   pbox = REGION_RECTS(prgn);
-   nbox = REGION_NUM_RECTS(prgn);
-
-   I830SelectBuffer(pScrn, I830_SELECT_DEPTH);
-
-   switch (pScrn->bitsPerPixel) {
-   case 16:
-      I830SetupForSolidFill(pScrn, 0xffff, GXcopy, -1);
-      break;
-   case 32:
-      I830SetupForSolidFill(pScrn, 0xffffff, GXcopy, -1);
-      break;
-   }
-
-   while (nbox--) {
-      I830SubsequentSolidFillRect(pScrn, pbox->x1, pbox->y1,
-				  pbox->x2 - pbox->x1, pbox->y2 - pbox->y1);
-      pbox++;
    }
 
    I830SelectBuffer(pScrn, I830_SELECT_FRONT);
@@ -1280,6 +1275,7 @@ I830DRIMoveBuffers(WindowPtr pParent, DDXPointRec ptOldOrg,
 
    int dx = pParent->drawable.x - ptOldOrg.x;
    int dy = pParent->drawable.y - ptOldOrg.y;
+   int buffer, first_buffer, last_buffer;
 
    /* If the copy will overlap in Y, reverse the order */
    if (dy > 0) {
@@ -1361,44 +1357,47 @@ I830DRIMoveBuffers(WindowPtr pParent, DDXPointRec ptOldOrg,
    /* SelectBuffer isn't really a good concept for the i810.
     */
    I830EmitFlush(pScrn);
-   I830SetupForScreenToScreenCopy(pScrn, xdir, ydir, GXcopy, -1, -1);
-   for (; nbox--; pbox++) {
-
-      int x1 = pbox->x1;
-      int y1 = pbox->y1;
-      int destx = x1 + dx;
-      int desty = y1 + dy;
-      int w = pbox->x2 - x1 + 1;
-      int h = pbox->y2 - y1 + 1;
-
-      if (destx < 0)
-	 x1 -= destx, w += destx, destx = 0;
-      if (desty < 0)
-	 y1 -= desty, h += desty, desty = 0;
-      if (destx + w > screenwidth)
-	 w = screenwidth - destx;
-      if (desty + h > screenheight)
-	 h = screenheight - desty;
-      if (w <= 0)
-	 continue;
-      if (h <= 0)
+   first_buffer = I830_SELECT_BACK;
+   last_buffer = I830_SELECT_DEPTH;
+   if (pI830->third_buffer)
+      last_buffer = I830_SELECT_THIRD;
+
+   for (buffer = first_buffer; buffer <= last_buffer; buffer++) {
+      if (!I830SelectBuffer(pScrn, buffer))
 	 continue;
+      I830SetupForScreenToScreenCopy(pScrn, xdir, ydir, GXcopy, -1, -1);
+      pbox = REGION_RECTS(prgnSrc);
+      nbox = REGION_NUM_RECTS(prgnSrc);
+      for (; nbox--; pbox++) {
+
+	 int x1 = pbox->x1;
+	 int y1 = pbox->y1;
+	 int destx = x1 + dx;
+	 int desty = y1 + dy;
+	 int w = pbox->x2 - x1 + 1;
+	 int h = pbox->y2 - y1 + 1;
+
+	 if (destx < 0)
+	    x1 -= destx, w += destx, destx = 0;
+	 if (desty < 0)
+	    y1 -= desty, h += desty, desty = 0;
+	 if (destx + w > screenwidth)
+	    w = screenwidth - destx;
+	 if (desty + h > screenheight)
+	    h = screenheight - desty;
+	 if (w <= 0)
+	    continue;
+	 if (h <= 0)
+	    continue;
 
-      if (I810_DEBUG & DEBUG_VERBOSE_DRI)
-	 ErrorF("MoveBuffers %d,%d %dx%d dx: %d dy: %d\n",
-		x1, y1, w, h, dx, dy);
+	 if (I810_DEBUG & DEBUG_VERBOSE_DRI)
+	    ErrorF("MoveBuffers %d,%d %dx%d dx: %d dy: %d\n",
+		   x1, y1, w, h, dx, dy);
 
-      I830SelectBuffer(pScrn, I830_SELECT_BACK);
-      I830SubsequentScreenToScreenCopy(pScrn, x1, y1, destx, desty, w, h);
-      if (pI830->third_buffer) {
-	 I830SelectBuffer(pScrn, I830_SELECT_THIRD);
 	 I830SubsequentScreenToScreenCopy(pScrn, x1, y1, destx, desty, w, h);
       }
-      if (!IS_I965G(pI830)) {
-         I830SelectBuffer(pScrn, I830_SELECT_DEPTH);
-         I830SubsequentScreenToScreenCopy(pScrn, x1, y1, destx, desty, w, h);
-      }
    }
+
    I830SelectBuffer(pScrn, I830_SELECT_FRONT);
    I830EmitFlush(pScrn);
 
-- 
1.6.0.3

