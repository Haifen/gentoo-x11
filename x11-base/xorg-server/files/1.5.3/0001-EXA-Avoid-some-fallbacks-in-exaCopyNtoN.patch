From 9f4a09976a0af241b75f8c50e2615a8b24f06c17 Mon Sep 17 00:00:00 2001
From: Tilman Sauerbeck <tilman@code-monkey.de>
Date: Wed, 16 Apr 2008 16:20:19 +0200
Subject: [PATCH 01/36] EXA: Avoid some fallbacks in exaCopyNtoN.

In some cases we can still do the copying in hardware even if the
dimensions of the pixmaps are out of range. This is true when the boxes
that we're to copy are all in the card's range.
(cherry picked from commit 886af8f3849a0fcfc6b63a9695107ce26d7a6955)
---
 exa/exa_accel.c |   32 ++++++++++++++++++++++++++------
 1 files changed, 26 insertions(+), 6 deletions(-)

diff --git a/exa/exa_accel.c b/exa/exa_accel.c
index 3ec9625..b679fd4 100644
--- a/exa/exa_accel.c
+++ b/exa/exa_accel.c
@@ -441,16 +441,36 @@ exaCopyNtoN (DrawablePtr    pSrcDrawable,
     pDstExaPixmap = ExaGetPixmapPriv (pDstPixmap);
 
     /* Check whether the accelerator can use this pixmap.
-     * FIXME: If it cannot, use temporary pixmaps so that the drawing
-     * happens within limits.
+     * If the pitch of the pixmaps is out of range, there's nothing
+     * we can do but fall back to software rendering.
      */
-    if (pSrcExaPixmap->accel_blocked || pDstExaPixmap->accel_blocked)
-    {
+    if (pSrcExaPixmap->accel_blocked & EXA_RANGE_PITCH ||
+        pDstExaPixmap->accel_blocked & EXA_RANGE_PITCH)
 	goto fallback;
-    } else {
-	exaDoMigration (pixmaps, 2, TRUE);
+
+    /* If the width or the height of either of the pixmaps
+     * is out of range, check whether the boxes are actually out of the
+     * addressable range as well. If they aren't, we can still do
+     * the copying in hardware.
+     */
+    if (pSrcExaPixmap->accel_blocked || pDstExaPixmap->accel_blocked) {
+        int i;
+
+        for (i = 0; i < nbox; i++) {
+            /* src */
+            if ((pbox[i].x2 + dx + src_off_x) >= pExaScr->info->maxX ||
+                (pbox[i].y2 + dy + src_off_y) >= pExaScr->info->maxY)
+                goto fallback;
+
+            /* dst */
+            if ((pbox[i].x2 + dst_off_x) >= pExaScr->info->maxX ||
+                (pbox[i].y2 + dst_off_y) >= pExaScr->info->maxY)
+                goto fallback;
+        }
     }
 
+    exaDoMigration (pixmaps, 2, TRUE);
+
     /* Mixed directions must be handled specially if the card is lame */
     if ((pExaScr->info->flags & EXA_TWO_BITBLT_DIRECTIONS) &&
 	reverse != upsidedown) {
-- 
1.6.0.3

